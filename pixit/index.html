<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pixit</title>
    <style>
      html {
        font-size: 16px;
        font-family: Arial, Helvetica, sans-serif;
      }

      body {
        background-color: #eee;
        margin: 0;
      }

      header {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        padding: 0.3rem 1.5rem;
        background-color: #fff;
      }

      main {
        padding: 1.5rem;
      }

      button {
        background-color: #ccc;
        border: none;
        border-radius: 5px;
        color: #333;
        font-size: 1rem;
        font-weight: 700;
        padding: 0.5rem 1rem;
        cursor: pointer;
      }

      .controller-number > label {
        display: inline-flex;
      }

      .controller-number > label:first-child {
        margin-right: 2rem;
      }

      .controller-number input {
        margin-left: 1rem;
      }

      .color-palette {
        align-items: center;
        background-color: #fff;
        border-radius: 1rem;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        margin-bottom: 1.5rem;
        padding: 1rem;
      }

      .btn-color {
        border: 1px solid #ccc;
        border-radius: 50%;
        height: 1rem;
        width: 1rem;
        padding: 0;
      }

      .btn-color.selected {
        border-style: dotted;
        border-width: 5px;
        pointer-events: none;
      }

      .container {
        height: 70vh;
        margin: 0 auto;
        width: 90vw;
        position: relative;
      }

      canvas {
        border: 1px solid black;
      }

      .download {
        margin-top: 1rem;
        display: flex;
        justify-content: center;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>PIXIT</h1>
      <div class="controller-number">
        <label for="width">
          Width
          <input
            type="range"
            min="1"
            max="100"
            id="width"
            name="width"
            value="10"
          />
        </label>
        <label for="height">
          Height
          <input
            type="range"
            min="1"
            max="100"
            id="height"
            name="height"
            value="10"
          />
        </label>
      </div>
      <button type="button" id="reset">reset</button>
    </header>
    <main>
      <section id="palette" class="color-palette"></section>
      <section id="canvas-container" class="container"></section>
      <section class="download">
        <button type="button" id="download">Download drawing as image</button>
      </section>
    </main>

    <script type="text/javascript">
      (function () {
        const colors = [
          "#000000",
          "#808080",
          "#98AFC7",
          "#2B547E",
          "#151B54",
          "#00008B",
          "#0000FF",
          "#1E90FF",
          "#4682B4",
          "#00BFFF",
          "#87CEFA",
          "#00FFFF",
          "#16E2F5",
          "#66CDAA",
          "#40E0D0",
          "#20B2AA",
          "#008B8B",
          "#033E3E",
          "#1F6357",
          "#2E8B57",
          "#3CB371",
          "#556B2F",
          "#228B22",
          "#006400",
          "#004225",
          "#00FF00",
          "#7FFF00",
          "#E2F516",
          "#F0E68C",
          "#FFFF00",
          "#FFA500",
          "#F4A460",
          "#C19A6B",
          "#AA6C39",
          "#513B1C",
          "#7E3517",
          "#C04000",
          "#CD5C5C",
          "#E55B3C",
          "#FF0000",
          "#B22222",
          "#550A35",
          "#872657",
          "#E38AAE",
          "#DB7093",
          "#FF69B4",
          "#FF1493",
          "#C71585",
          "#FF00FF",
          "#F2A2E8",
          "#FFF",
        ];

        const container = document.getElementById("palette");
        colors.forEach((color) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "btn-color";
          button.style.backgroundColor = color;
          button.dataset.color = color;
          button.ariaLabel = button.title = `Select color ${color}`;
          container.append(button);
        });
      })();

      (function () {
        const CONTAINER = document.getElementById("canvas-container"),
          CANVAS_HANDLER = handleCanvas();

        CANVAS_HANDLER.init(CONTAINER);

        if (CANVAS_HANDLER.isCanvasSupported) {
          const STATE_PIXEL_DIMENSIONS = statePixelsDimensions(),
            STATE_SELECTED_PIXELS = stateDrawnPixels(),
            STATE_SELECTED_COLOR = stateSelectedColour();

          window.addEventListener("resize", function () {
            CANVAS_HANDLER.setCanvasDimensionsWithWindow();
            CANVAS_HANDLER.drawPixelsGrid(
              STATE_PIXEL_DIMENSIONS.getDimensionsObject()
            );
            // TODO color drawn pixels
          });

          CANVAS_HANDLER.drawPixelsGrid(
            STATE_PIXEL_DIMENSIONS.getDimensionsObject()
          );

          const firstColorPalette = document.querySelector(".btn-color"),
            firstColor = firstColorPalette.dataset.color;
          firstColorPalette.classList.add("selected");
          STATE_SELECTED_COLOR.setColor(firstColor);

          document.querySelectorAll(".btn-color").forEach((btn) => {
            btn.addEventListener("click", (event) => {
              document
                .querySelector(".btn-color.selected")
                .classList.remove("selected");

              event.target.classList.add("selected");
              STATE_SELECTED_COLOR.setColor(event.target.dataset.color);
            });
          });

          let isMouseDown = false,
            latestClientX,
            latestClientY,
            setMouseDownToTrue = (event) => {
              event.preventDefault();
              isMouseDown = true;
            },
            setMouseDownToFalse = (event) => {
              event.preventDefault();
              isMouseDown = false;
            };

          function colorPixelOnMouseMove(event) {
            event.preventDefault();
            if (isMouseDown) {
              const { top, left } = CANVAS_HANDLER.positionInsideTheViewport;

              const eventX = event.changedTouches
                  ? event.changedTouches[0].pageX
                  : event.clientX,
                eventY = event.changedTouches
                  ? event.changedTouches[0].pageY
                  : event.clientY;
              const x = eventX - left,
                y = eventY - top;

              const mousedMovedEnterNewPixel =
                !latestClientX ||
                Math.abs(latestClientX - x) >
                  STATE_PIXEL_DIMENSIONS.getWidth() / 3 ||
                Math.abs(latestClientY - y) >
                  STATE_PIXEL_DIMENSIONS.getHeight() / 3;

              if (mousedMovedEnterNewPixel) {
                latestClientX = x;
                latestClientY = y;

                const coloredPixelCoordinates = CANVAS_HANDLER.colorPixel(
                  [x, y],
                  STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                  STATE_SELECTED_COLOR.getColor()
                );

                STATE_SELECTED_PIXELS.add({
                  coordinates: [...coloredPixelCoordinates],
                  color: STATE_SELECTED_COLOR.getColor(),
                });
              }
            }
          }

          /**
           * @param {1|0} type - 1 addEventListener, 0 - removeEventListener
           */
          function addRemoveCanvasEventsListener(type) {
            const method = ["removeEventListener", "addEventListener"][type];

            ["mousedown", "touchstart"].forEach((eventName) => {
              CANVAS_HANDLER.canvas[method](eventName, setMouseDownToTrue);
            });

            ["mousemove", "touchmove"].forEach((eventName) => {
              CANVAS_HANDLER.canvas[method](eventName, colorPixelOnMouseMove);
            });

            ["mouseup", "touchend"].forEach((eventName) => {
              CANVAS_HANDLER.canvas[method](eventName, setMouseDownToFalse);
            });
          }

          function redrawPixels() {
            CANVAS_HANDLER.drawPixelsGrid(
              STATE_PIXEL_DIMENSIONS.getDimensionsObject()
            );
            CANVAS_HANDLER.createCanvas();

            STATE_SELECTED_PIXELS.all.forEach((pixelInfo) => {
              const pixelCanvasCoordinates = getCanvasCoordinatesFromPixel(
                STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                pixelInfo.coordinates
              );
              CANVAS_HANDLER.colorPixel(
                pixelInfo.coordinates,
                STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                pixelInfo.color
              );
            });

            addRemoveCanvasEventsListener(0);
            addRemoveCanvasEventsListener(1);
          }

          addRemoveCanvasEventsListener(1);

          document
            .getElementById("reset")
            .addEventListener("click", function () {
              document.querySelector("input[name='width']").value = 10;
              document.querySelector("input[name='height").value = 10;
              STATE_PIXEL_DIMENSIONS.setWidth(10);
              STATE_PIXEL_DIMENSIONS.setHeight(10);

              STATE_SELECTED_PIXELS.removeAll();

              CANVAS_HANDLER.setCanvasDimensionsWithWindow();

              redrawPixels();

              // TODO reset color
            });

          document
            .querySelector("input[name='width']")
            .addEventListener("change", function (event) {
              const width = +event.target.value;
              STATE_PIXEL_DIMENSIONS.setWidth(width);

              redrawPixels();
            });

          document
            .querySelector("input[name='height']")
            .addEventListener("change", function (event) {
              const height = +event.target.value;
              STATE_PIXEL_DIMENSIONS.setHeight(height);

              redrawPixels();
            });

          document.getElementById("download").addEventListener("click", () => {
            const tagA = document.createElement("a");
            tagA.download = "image";
            tagA.target = "_blank";
            tagA.href = CANVAS_HANDLER.imageURL();
            tagA.click();
          });
        } else {
          CONTAINER.innerText =
            "This app uses canvas, which is not supported by your browser";
        }

        /*state*/
        function statePixelsDimensions(
          initialPixelWidth = 10,
          initialPixedHeight = 10
        ) {
          const dimensions = {
            width: initialPixelWidth,
            height: initialPixedHeight,
          };

          return {
            setWidth: function (value) {
              dimensions.width = value;
            },
            setHeight: function (value) {
              dimensions.height = value;
            },
            getWidth: function () {
              return dimensions.width;
            },
            getHeight: function () {
              return dimensions.height;
            },
            getDimensionsObject: function () {
              return { width: dimensions.width, height: dimensions.height };
            },
          };
        }

        function stateDrawnPixels() {
          let _pixelsInfo = [];

          return {
            get all() {
              return [..._pixelsInfo];
            },
            /**
             * @param {object} info
             * @param {array} info.coordinates
             * @param {string} info.color
             */
            add: function (info) {
              _pixelsInfo.push(info);
            },
            removeAll: function () {
              _pixelsInfo = [];
            },
          };
        }

        function stateSelectedColour() {
          let color = "#000";

          return {
            setColor: function (value) {
              color = value;
            },
            getColor: function () {
              return color;
            },
          };
        }

        /*canvas*/
        function handleCanvas() {
          let _canvasNode, _canvasPositionInsideTheViewport, _container;

          function _updateCanvasPositionInsideTheViewport() {
            const { top, left } = _canvasNode.getBoundingClientRect();

            _canvasPositionInsideTheViewport = { top, left };
          }

          return {
            init: function (containerElement) {
              _container = containerElement;
              this.createCanvas();
            },
            createCanvas() {
              const id = "pixit";

              if ((prevCanvas = document.getElementById(id))) {
                _canvasNode = null;
                _container.removeChild(prevCanvas);
              }

              _canvasNode = document.createElement("canvas");
              _canvasNode.id = id;
              _canvasNode.innerText = "This is the are where you can draw";
              this.context.fillStyle = "#ffffff";

              _container.appendChild(_canvasNode);

              this.setCanvasDimensionsWithWindow();
            },
            get canvas() {
              return _canvasNode;
            },
            get context() {
              return _canvasNode.getContext("2d");
            },
            get isCanvasSupported() {
              return !!_canvasNode.getContext;
            },
            get positionInsideTheViewport() {
              return { ..._canvasPositionInsideTheViewport };
            },
            /**
             * @param {object} pixelDimension
             * @param {number} pixelDimension.width
             * @param {number} pixelDimension.height
             * */
            drawPixelsGrid(pixelDimension) {
              const id = "pixit-grid";

              if ((prevCanvas = document.getElementById(id))) {
                _container.removeChild(prevCanvas);
              }

              let _gridCanvasNode = document.createElement("canvas");
              _gridCanvasNode.id = id;
              _gridCanvasNode.innerText =
                "This is the grid of the area where you can draw";
              _gridCanvasNode.width = this.canvas.width;
              _gridCanvasNode.height = this.canvas.height;
              _gridCanvasNode.style.zIndex = -1;
              _gridCanvasNode.style.position = "absolute";
              _gridCanvasNode.style.top = 0;
              _gridCanvasNode.style.left = 0;
              _gridCanvasNode.style.bottom = 0;
              _gridCanvasNode.style.right = 0;
              _container.appendChild(_gridCanvasNode);

              let currentX = 0,
                context = _gridCanvasNode.getContext("2d");

              while (currentX < _gridCanvasNode.width) {
                context.moveTo(currentX, 0);
                context.lineTo(currentX, _gridCanvasNode.height);
                currentX = currentX + pixelDimension.width;
              }

              let currentY = 0;
              while (currentY < _gridCanvasNode.height) {
                context.moveTo(0, currentY);
                context.lineTo(_gridCanvasNode.width, currentY);
                currentY = currentY + pixelDimension.height;
              }

              context.strokeStyle = "#ccc";
              context.stroke();
            },
            setCanvasDimensionsWithWindow() {
              this.canvas.width = _container.offsetWidth;
              this.canvas.height = _container.offsetHeight;
              _updateCanvasPositionInsideTheViewport();
            },
            /**
             * @param {array} canvasPointCoordinates
             * @param {number} canvasPointCoordinates[0] - x
             * @param {number} canvasPointCoordinates[1] - y
             * @param {object} pixelDimension
             * @param {number} pixelDimension.width
             * @param {number} pixelDimension.height
             * @param {string} color
             */
            colorPixel([x, y], pixelDimension, color) {
              const pixelCoordinates = getPixelFromCanvasPoint(pixelDimension, [
                  x,
                  y,
                ]),
                [pixelCoordinateX, pixelCoordinateY] =
                  getCanvasCoordinatesFromPixel(
                    pixelDimension,
                    pixelCoordinates
                  );

              this.context.beginPath();
              this.context.lineWidth = "1";
              this.context.fillStyle = color;
              this.context.rect(
                pixelCoordinateX,
                pixelCoordinateY,
                pixelDimension.width,
                pixelDimension.height
              );
              this.context.fill();

              return pixelCoordinates;
            },
            imageURL() {
              return this.canvas.toDataURL("image/png");
            },
          };
        }

        /*utils*/

        /**
         * Return the grid pixel corresponding to canvas coordinates
         * @param {object} pixelDimension
         * @param {number} pixelDimension.width
         * @param {number} pixelDimension.height
         * @param {array} canvasPointCoordinates
         * @param {number} canvasPointCoordinates[0] - x
         * @param {number} canvasPointCoordinates[1] - y
         */
        function getPixelFromCanvasPoint(
          pixelDimension,
          canvasPointCoordinates
        ) {
          const xCoordinates = parseInt(
            canvasPointCoordinates[0] / pixelDimension.width
          );
          const yCoordinates = parseInt(
            canvasPointCoordinates[1] / pixelDimension.height
          );

          return [xCoordinates, yCoordinates];
        }

        /**
         * Return the canvas coordinates of the pixel
         * @param {object} pixelDimension
         * @param {number} pixelDimension.width
         * @param {number} pixelDimension.height
         * @param {array} pixelCoordinates
         * @param {number} pixelCoordinates[0] - x
         * @param {number} pixelCoordinates[1] - y
         */
        function getCanvasCoordinatesFromPixel(
          pixelDimension,
          pixelCoordinates
        ) {
          const [x, y] = pixelCoordinates;
          return [x * pixelDimension.width, y * pixelDimension.height];
        }
        window.test = function () {
          function expectForNoObjects(description, output, expected) {
            if (output == expected) {
              console.log("[SUCCEED]", description);
            } else
              console.error(
                "[FAILED]",
                description,
                `expected: ${expected}, but received: ${output}`
              );
          }

          let output = getPixelFromCanvasPoint(
            { width: 10, height: 10 },
            [0, 0]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            0
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            0
          );

          output = getPixelFromCanvasPoint({ width: 10, height: 10 }, [25, 0]);
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            2
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            0
          );

          output = getPixelFromCanvasPoint(
            { width: 10, height: 10 },
            [255, 100]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            25
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            10
          );

          output = getCanvasCoordinatesFromPixel(
            { width: 10, height: 10 },
            [255, 100]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            2550
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            1000
          );
        };
      })();
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pixit</title>
    <style>
      .container {
        height: 70vh;
        margin: 0 auto;
        width: 90vw;
      }

      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <main>
      <section id="canvas-container" class="container"></section>
    </main>

    <script type="text/javascript">
      (function () {
        const CONTAINER = document.getElementById("canvas-container"),
          CANVAS_HANDLER = handleCanvas();

        CANVAS_HANDLER.init(CONTAINER);

        if (CANVAS_HANDLER.isCanvasSupported) {
          const STATE_PIXEL_DIMENSIONS = statePixelsDimensions(),
            STATE_SELECTED_PIXELS = stateDrawnPixels(),
            STATE_SELECTED_COLOR = stateSelectedColour();

          window.addEventListener("resize", function () {
            CANVAS_HANDLER.setCanvasDimensionsWithWindow();
            CANVAS_HANDLER.drawPixelsGrid(
              STATE_PIXEL_DIMENSIONS.getDimensionsObject()
            );
            // TODO color drawn pixels
          });

          CANVAS_HANDLER.setCanvasDimensionsWithWindow();
          CANVAS_HANDLER.drawPixelsGrid(
            STATE_PIXEL_DIMENSIONS.getDimensionsObject()
          );

          let isMouseDown = false,
            latestClientX,
            latestClientY;

          function colorPixelOnMouseMove(event) {
            if (isMouseDown) {
              const { top, left } = CANVAS_HANDLER.positionInsideTheViewport;
              const x = event.clientX - left,
                y = event.clientY - top;

              const mousedMovedEnterNewPixel =
                !latestClientX ||
                Math.abs(latestClientX - x) >
                  STATE_PIXEL_DIMENSIONS.getWidth() / 2 ||
                Math.abs(latestClientY - y) >
                  STATE_PIXEL_DIMENSIONS.getHeight() / 2;

              if (mousedMovedEnterNewPixel) {
                latestClientX = x;
                latestClientY = y;

                const coloredPixelCoordinates = CANVAS_HANDLER.colorPixel(
                  [x, y],
                  STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                  STATE_SELECTED_COLOR.getColor()
                );

                STATE_SELECTED_PIXELS.add(coloredPixelCoordinates);
              }
            }
          }

          CANVAS_HANDLER.canvas.addEventListener("mousedown", (event) => {
            isMouseDown = true;
          });
          CANVAS_HANDLER.canvas.addEventListener("mousemove", (event) => {
            colorPixelOnMouseMove(event);
          });
          CANVAS_HANDLER.canvas.addEventListener("mouseup", (event) => {
            isMouseDown = false;
          });
        } else {
          CONTAINER.innerText =
            "This app uses canvas, which is not supported by your browser";
        }

        /*state*/
        function statePixelsDimensions(
          initialPixelWidth = 10,
          initialPixedHeight = 10
        ) {
          const dimensions = {
            width: initialPixelWidth,
            height: initialPixedHeight,
          };

          return {
            setWidth: function (value) {
              dimensions.width = value;
            },
            setHeight: function (value) {
              dimensions.height = value;
            },
            getWidth: function () {
              return dimensions.width;
            },
            getHeight: function () {
              return dimensions.height;
            },
            getDimensionsObject: function () {
              return { width: dimensions.width, height: dimensions.height };
            },
          };
        }

        function stateDrawnPixels() {
          const pixelCoordinates = [];

          return {
            add: function (coordinates) {
              pixelCoordinates.push(coordinates);
            },
            getAll: function () {
              return [...pixelCoordinates];
            },
          };
        }

        function stateSelectedColour() {
          let color = "#000";

          return {
            setColor: function (value) {
              color = value;
            },
            getColor: function () {
              return color;
            },
          };
        }

        /*canvas*/
        function handleCanvas() {
          let _canvasNode, _canvasPositionInsideTheViewport, _container;

          function _updateCanvasPositionInsideTheViewport() {
            const { top, left } = _canvasNode.getBoundingClientRect();

            _canvasPositionInsideTheViewport = { top, left };
          }

          return {
            init: function (containerElement) {
              _canvasNode = document.createElement("canvas");
              _canvasNode.id = "pixit";
              _canvasNode.innerText = "This is the are where you can draw";
              _container = containerElement;
              containerElement.appendChild(_canvasNode);
            },
            get canvas() {
              return _canvasNode;
            },
            get context() {
              return _canvasNode.getContext("2d");
            },
            get isCanvasSupported() {
              return !!_canvasNode.getContext;
            },
            get positionInsideTheViewport() {
              return { ..._canvasPositionInsideTheViewport };
            },
            /**
             * @param {object} pixelDimension
             * @param {number} pixelDimension.width
             * @param {number} pixelDimension.height
             * */
            drawPixelsGrid(pixelDimension) {
              let currentX = 0;
              while (currentX < this.canvas.width) {
                this.context.moveTo(currentX, 0);
                this.context.lineTo(currentX, this.canvas.height);
                currentX = currentX + pixelDimension.width;
              }

              let currentY = 0;
              while (currentY < this.canvas.height) {
                this.context.moveTo(0, currentY);
                this.context.lineTo(this.canvas.width, currentY);
                currentY = currentY + pixelDimension.height;
              }

              this.context.strokeStyle = "#ccc";
              this.context.stroke();
            },
            setCanvasDimensionsWithWindow() {
              this.canvas.width = _container.offsetWidth;
              this.canvas.height = _container.offsetHeight;
              _updateCanvasPositionInsideTheViewport();
            },
            /**
             * @param {array} canvasPointCoordinates
             * @param {number} canvasPointCoordinates[0] - x
             * @param {number} canvasPointCoordinates[1] - y
             * @param {object} pixelDimension
             * @param {number} pixelDimension.width
             * @param {number} pixelDimension.height
             * @param {string} color
             */
            colorPixel([x, y], pixelDimension, color) {
              const pixelCoordinates = getPixelFromCanvasPoint(pixelDimension, [
                  x,
                  y,
                ]),
                [pixelCoordinateX, pixelCoordinateY] =
                  getCanvasCoordinatesFromPixel(
                    pixelDimension,
                    pixelCoordinates
                  );

              this.context.beginPath();
              this.context.lineWidth = "1";
              this.context.fillStyle = color;
              this.context.rect(
                pixelCoordinateX,
                pixelCoordinateY,
                pixelDimension.width,
                pixelDimension.height
              );
              this.context.fill();

              return [pixelCoordinateX, pixelCoordinateY];
            },
          };
        }

        /*utils*/

        /**
         *
         * @param {object} pixelDimension
         * @param {number} pixelDimension.width
         * @param {number} pixelDimension.height
         * @param {array} canvasPointCoordinates
         * @param {number} canvasPointCoordinates[0] - x
         * @param {number} canvasPointCoordinates[1] - y
         */
        function getPixelFromCanvasPoint(
          pixelDimension,
          canvasPointCoordinates
        ) {
          const xCoordinates = parseInt(
            canvasPointCoordinates[0] / pixelDimension.width
          );
          const yCoordinates = parseInt(
            canvasPointCoordinates[1] / pixelDimension.height
          );

          return [xCoordinates, yCoordinates];
        }

        /**
         * @param {object} pixelDimension
         * @param {number} pixelDimension.width
         * @param {number} pixelDimension.height
         * @param {array} pixelCoordinates
         * @param {number} pixelCoordinates[0] - x
         * @param {number} pixelCoordinates[1] - y
         */
        function getCanvasCoordinatesFromPixel(
          pixelDimension,
          pixelCoordinates
        ) {
          const [x, y] = pixelCoordinates;
          return [x * pixelDimension.width, y * pixelDimension.height];
        }
        window.test = function () {
          function expectForNoObjects(description, output, expected) {
            if (output == expected) {
              console.log("[SUCCEED]", description);
            } else
              console.error(
                "[FAILED]",
                description,
                `expected: ${expected}, but received: ${output}`
              );
          }

          let output = getPixelFromCanvasPoint(
            { width: 10, height: 10 },
            [0, 0]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            0
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            0
          );

          output = getPixelFromCanvasPoint({ width: 10, height: 10 }, [25, 0]);
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            2
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            0
          );

          output = getPixelFromCanvasPoint(
            { width: 10, height: 10 },
            [255, 100]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            25
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            10
          );

          output = getCanvasCoordinatesFromPixel(
            { width: 10, height: 10 },
            [255, 100]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            2550
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            1000
          );
        };
      })();
    </script>
  </body>
</html>

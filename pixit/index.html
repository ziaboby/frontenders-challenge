<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pixit</title>
    <style>
      html {
        font-size: 16px;
        font-family: Arial, Helvetica, sans-serif;
      }

      body {
        margin: 1.5rem;
      }

      header {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      header > button {
        border: none;
        border-radius: 5px;
        color: #333;
        font-size: 1rem;
        font-weight: 700;
        padding: 0.5rem 1rem;
        cursor: pointer;
      }

      .controller-number > label {
        display: inline-flex;
      }

      .controller-number > label:first-child {
        margin-right: 2rem;
      }

      .controller-number input {
        margin-left: 1rem;
      }

      .container {
        height: 70vh;
        margin: 0 auto;
        width: 90vw;
        position: relative;
      }

      canvas {
        border: 1px solid black;
      }

      .download {
        margin-top: 1rem;
        display: flex;
        justify-content: center;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <h1>PIXIT</h1>
        <div class="controller-number">
          <label for="width">
            Width
            <input type="range" min="1" max="100" name="width" value="10" />
          </label>
          <label for="height">
            Height
            <input type="range" min="1" max="100" name="height" value="10" />
          </label>
        </div>
        <button type="button" id="reset">reset</button>
      </header>

      <section id="canvas-container" class="container"></section>
      <section class="download">
        <button type="button" id="download">Download drawing as image</button>
      </section>
    </main>

    <script type="text/javascript">
      (function () {
        const CONTAINER = document.getElementById("canvas-container"),
          CANVAS_HANDLER = handleCanvas();

        CANVAS_HANDLER.init(CONTAINER);

        if (CANVAS_HANDLER.isCanvasSupported) {
          const STATE_PIXEL_DIMENSIONS = statePixelsDimensions(),
            STATE_SELECTED_PIXELS = stateDrawnPixels(),
            STATE_SELECTED_COLOR = stateSelectedColour();

          window.addEventListener("resize", function () {
            CANVAS_HANDLER.setCanvasDimensionsWithWindow();
            CANVAS_HANDLER.drawPixelsGrid(
              STATE_PIXEL_DIMENSIONS.getDimensionsObject()
            );
            // TODO color drawn pixels
          });

          CANVAS_HANDLER.drawPixelsGrid(
            STATE_PIXEL_DIMENSIONS.getDimensionsObject()
          );

          let isMouseDown = false,
            latestClientX,
            latestClientY,
            setMouseDownToTrue = () => {
              isMouseDown = true;
            },
            setMouseDownToFalse = () => {
              isMouseDown = false;
            };

          function colorPixelOnMouseMove(event) {
            if (isMouseDown) {
              const { top, left } = CANVAS_HANDLER.positionInsideTheViewport;
              const x = event.clientX - left,
                y = event.clientY - top;

              const mousedMovedEnterNewPixel =
                !latestClientX ||
                Math.abs(latestClientX - x) >
                  STATE_PIXEL_DIMENSIONS.getWidth() / 3 ||
                Math.abs(latestClientY - y) >
                  STATE_PIXEL_DIMENSIONS.getHeight() / 3;

              if (mousedMovedEnterNewPixel) {
                latestClientX = x;
                latestClientY = y;

                const coloredPixelCoordinates = CANVAS_HANDLER.colorPixel(
                  [x, y],
                  STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                  STATE_SELECTED_COLOR.getColor()
                );

                STATE_SELECTED_PIXELS.add(coloredPixelCoordinates);
              }
            }
          }

          function addCanvasEventsListener() {
            CANVAS_HANDLER.canvas.addEventListener(
              "mousedown",
              setMouseDownToTrue
            );
            CANVAS_HANDLER.canvas.addEventListener(
              "mousemove",
              colorPixelOnMouseMove
            );
            CANVAS_HANDLER.canvas.addEventListener(
              "mouseup",
              setMouseDownToFalse
            );
          }

          function removeCanvasEventsListener() {
            CANVAS_HANDLER.canvas.removeEventListener(
              "mousedown",
              setMouseDownToTrue
            );
            CANVAS_HANDLER.canvas.removeEventListener(
              "mousemove",
              colorPixelOnMouseMove
            );
            CANVAS_HANDLER.canvas.removeEventListener(
              "mouseup",
              setMouseDownToFalse
            );
          }

          addCanvasEventsListener();

          document
            .getElementById("reset")
            .addEventListener("click", function () {
              document.querySelector("input[name='width']").value = 10;
              document.querySelector("input[name='height").value = 10;
              STATE_PIXEL_DIMENSIONS.setWidth(10);
              STATE_PIXEL_DIMENSIONS.setHeight(10);

              CANVAS_HANDLER.setCanvasDimensionsWithWindow();
              CANVAS_HANDLER.drawPixelsGrid(
                STATE_PIXEL_DIMENSIONS.getDimensionsObject()
              );
              CANVAS_HANDLER.createCanvas();
              STATE_SELECTED_PIXELS.removeAll();

              removeCanvasEventsListener();
              addCanvasEventsListener();

              // TODO reset color
            });

          document
            .querySelector("input[name='width']")
            .addEventListener("change", function (event) {
              const width = +event.target.value;
              STATE_PIXEL_DIMENSIONS.setWidth(width);

              CANVAS_HANDLER.drawPixelsGrid(
                STATE_PIXEL_DIMENSIONS.getDimensionsObject()
              );
              CANVAS_HANDLER.createCanvas();

              STATE_SELECTED_PIXELS.getAll().forEach((pixelCoordinate) => {
                CANVAS_HANDLER.colorPixel(
                  pixelCoordinate,
                  STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                  STATE_SELECTED_COLOR.getColor()
                );
              });

              removeCanvasEventsListener();
              addCanvasEventsListener();
            });

          document
            .querySelector("input[name='height']")
            .addEventListener("change", function (event) {
              const height = +event.target.value;
              STATE_PIXEL_DIMENSIONS.setHeight(height);

              CANVAS_HANDLER.drawPixelsGrid(
                STATE_PIXEL_DIMENSIONS.getDimensionsObject()
              );
              CANVAS_HANDLER.createCanvas();

              STATE_SELECTED_PIXELS.getAll().forEach((pixelCoordinate) => {
                const pixelCanvasCoordinates = getCanvasCoordinatesFromPixel(
                  STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                  pixelCoordinate
                );
                CANVAS_HANDLER.colorPixel(
                  pixelCanvasCoordinates,
                  STATE_PIXEL_DIMENSIONS.getDimensionsObject(),
                  STATE_SELECTED_COLOR.getColor()
                );
              });

              removeCanvasEventsListener();
              addCanvasEventsListener();
            });

          document.getElementById("download").addEventListener("click", () => {
            const tagA = document.createElement("a");
            tagA.download = "image";
            tagA.target = "_blank";
            tagA.href = CANVAS_HANDLER.imageURL();
            tagA.click();
          });
        } else {
          CONTAINER.innerText =
            "This app uses canvas, which is not supported by your browser";
        }

        /*state*/
        function statePixelsDimensions(
          initialPixelWidth = 10,
          initialPixedHeight = 10
        ) {
          const dimensions = {
            width: initialPixelWidth,
            height: initialPixedHeight,
          };

          return {
            setWidth: function (value) {
              dimensions.width = value;
            },
            setHeight: function (value) {
              dimensions.height = value;
            },
            getWidth: function () {
              return dimensions.width;
            },
            getHeight: function () {
              return dimensions.height;
            },
            getDimensionsObject: function () {
              return { width: dimensions.width, height: dimensions.height };
            },
          };
        }

        function stateDrawnPixels() {
          let pixelCoordinates = [];

          return {
            add: function (coordinates) {
              pixelCoordinates.push(coordinates);
            },
            getAll: function () {
              return [...pixelCoordinates];
            },
            removeAll: function () {
              pixelCoordinates = [];
            },
          };
        }

        function stateSelectedColour() {
          let color = "#000";

          return {
            setColor: function (value) {
              color = value;
            },
            getColor: function () {
              return color;
            },
          };
        }

        /*canvas*/
        function handleCanvas() {
          let _canvasNode, _canvasPositionInsideTheViewport, _container;

          function _updateCanvasPositionInsideTheViewport() {
            const { top, left } = _canvasNode.getBoundingClientRect();

            _canvasPositionInsideTheViewport = { top, left };
          }

          return {
            init: function (containerElement) {
              _container = containerElement;
              this.createCanvas();
            },
            createCanvas() {
              const id = "pixit";

              if ((prevCanvas = document.getElementById(id))) {
                _canvasNode = null;
                _container.removeChild(prevCanvas);
              }

              _canvasNode = document.createElement("canvas");
              _canvasNode.id = id;
              _canvasNode.innerText = "This is the are where you can draw";
              this.context.fillStyle = "#ffffff";

              _container.appendChild(_canvasNode);

              this.setCanvasDimensionsWithWindow();
            },
            get canvas() {
              return _canvasNode;
            },
            get context() {
              return _canvasNode.getContext("2d");
            },
            get isCanvasSupported() {
              return !!_canvasNode.getContext;
            },
            get positionInsideTheViewport() {
              return { ..._canvasPositionInsideTheViewport };
            },
            /**
             * @param {object} pixelDimension
             * @param {number} pixelDimension.width
             * @param {number} pixelDimension.height
             * */
            drawPixelsGrid(pixelDimension) {
              const id = "pixit-grid";

              if ((prevCanvas = document.getElementById(id))) {
                _container.removeChild(prevCanvas);
              }

              let _gridCanvasNode = document.createElement("canvas");
              _gridCanvasNode.id = id;
              _gridCanvasNode.innerText =
                "This is the grid of the area where you can draw";
              _gridCanvasNode.width = this.canvas.width;
              _gridCanvasNode.height = this.canvas.height;
              _gridCanvasNode.style.zIndex = -1;
              _gridCanvasNode.style.position = "absolute";
              _gridCanvasNode.style.top = 0;
              _gridCanvasNode.style.left = 0;
              _gridCanvasNode.style.bottom = 0;
              _gridCanvasNode.style.right = 0;
              _container.appendChild(_gridCanvasNode);

              let currentX = 0,
                context = _gridCanvasNode.getContext("2d");

              while (currentX < _gridCanvasNode.width) {
                context.moveTo(currentX, 0);
                context.lineTo(currentX, _gridCanvasNode.height);
                currentX = currentX + pixelDimension.width;
              }

              let currentY = 0;
              while (currentY < _gridCanvasNode.height) {
                context.moveTo(0, currentY);
                context.lineTo(_gridCanvasNode.width, currentY);
                currentY = currentY + pixelDimension.height;
              }

              context.strokeStyle = "#ccc";
              context.stroke();
            },
            setCanvasDimensionsWithWindow() {
              this.canvas.width = _container.offsetWidth;
              this.canvas.height = _container.offsetHeight;
              _updateCanvasPositionInsideTheViewport();
            },
            /**
             * @param {array} canvasPointCoordinates
             * @param {number} canvasPointCoordinates[0] - x
             * @param {number} canvasPointCoordinates[1] - y
             * @param {object} pixelDimension
             * @param {number} pixelDimension.width
             * @param {number} pixelDimension.height
             * @param {string} color
             */
            colorPixel([x, y], pixelDimension, color) {
              const pixelCoordinates = getPixelFromCanvasPoint(pixelDimension, [
                  x,
                  y,
                ]),
                [pixelCoordinateX, pixelCoordinateY] =
                  getCanvasCoordinatesFromPixel(
                    pixelDimension,
                    pixelCoordinates
                  );

              this.context.beginPath();
              this.context.lineWidth = "1";
              this.context.fillStyle = color;
              this.context.rect(
                pixelCoordinateX,
                pixelCoordinateY,
                pixelDimension.width,
                pixelDimension.height
              );
              this.context.fill();

              return pixelCoordinates;
            },
            imageURL() {
              return this.canvas.toDataURL("image/png");
            },
          };
        }

        /*utils*/

        /**
         * Return the grid pixel corresponding to canvas coordinates
         * @param {object} pixelDimension
         * @param {number} pixelDimension.width
         * @param {number} pixelDimension.height
         * @param {array} canvasPointCoordinates
         * @param {number} canvasPointCoordinates[0] - x
         * @param {number} canvasPointCoordinates[1] - y
         */
        function getPixelFromCanvasPoint(
          pixelDimension,
          canvasPointCoordinates
        ) {
          const xCoordinates = parseInt(
            canvasPointCoordinates[0] / pixelDimension.width
          );
          const yCoordinates = parseInt(
            canvasPointCoordinates[1] / pixelDimension.height
          );

          return [xCoordinates, yCoordinates];
        }

        /**
         * Return the canvas coordinates of the pixel
         * @param {object} pixelDimension
         * @param {number} pixelDimension.width
         * @param {number} pixelDimension.height
         * @param {array} pixelCoordinates
         * @param {number} pixelCoordinates[0] - x
         * @param {number} pixelCoordinates[1] - y
         */
        function getCanvasCoordinatesFromPixel(
          pixelDimension,
          pixelCoordinates
        ) {
          const [x, y] = pixelCoordinates;
          return [x * pixelDimension.width, y * pixelDimension.height];
        }
        window.test = function () {
          function expectForNoObjects(description, output, expected) {
            if (output == expected) {
              console.log("[SUCCEED]", description);
            } else
              console.error(
                "[FAILED]",
                description,
                `expected: ${expected}, but received: ${output}`
              );
          }

          let output = getPixelFromCanvasPoint(
            { width: 10, height: 10 },
            [0, 0]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            0
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            0
          );

          output = getPixelFromCanvasPoint({ width: 10, height: 10 }, [25, 0]);
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            2
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            0
          );

          output = getPixelFromCanvasPoint(
            { width: 10, height: 10 },
            [255, 100]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            25
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            10
          );

          output = getCanvasCoordinatesFromPixel(
            { width: 10, height: 10 },
            [255, 100]
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - x",
            output[0],
            2550
          );
          expectForNoObjects(
            "getPixelFromCanvasPoint - should return the pixel coordinates based on the current position in the canvas - y",
            output[1],
            1000
          );
        };
      })();
    </script>
  </body>
</html>
